package parsing.customer.local;import czerkaloggers.RadioLogger;import entities.HashMax;import organization.OrganizationWithUId;import parsing.customer.Indicator;import parsing.customer.bootstrapper.LoaferLoader;import java.util.*;/** * Конкретный пацан в паттерне. Оперирует организациями, как * своими методами. Знает: какую реализация предложить, дабы * исполнить любую прихоть клиента. * @author Come_1LL_F00 aka Lenar Khannanov * @author Leargy aka Anton Sushkevich * @see Receiver * @see Commander */public class TotalCommander extends Commander<Integer, OrganizationWithUId> {  /**   * Стандартный конструктор   * менеджера коллекции   * @param logger   */  public TotalCommander(LoaferLoader<OrganizationWithUId> loader) { super(loader); }  /**   * Пояснит за коллекцию и ее элементы. Помнит даже   * дату рождения своей подопечной и ее корни   * @return текстовая информация о хранимой коллекции   */  @Override  public String review() {    Class studyee = database.getClass();    StringBuilder info = new StringBuilder("\t* Collection canonical name: " + studyee.getCanonicalName() + ";\n");    info.append("\t* Collection creation date: " + creationDate + ";\n");    info.append("\t* Collection element type name: Organization extends Mappable<Integer>;\n");    info.append("\t* Is collection empty?: " + database.isEmpty() + ";\n");    info.append("\t* Collection size: " + database.size() + ";");    logger.info("Collection info are provided");//    peacher().logboard(0, "Данные о коллекции успешно предоставлены");    return info.toString();  }  /**   * Обший метод для добавления элемента в коллекцию   * @param key ключ элемента, на который пишется элемент   * @param value записываемый элемент   * @param menace  признак, по которому данный элемент должен добавится   */  @Override  public void add(Integer[] key, OrganizationWithUId[] value, Indicator menace) {    synchronized (database) {      // проверка: добавляем ли мы ошибку природы      if (value[0] != null) {        // проверка: нужно ли добавлять данное детище        if (menace.verify(value[0])) {          value[0] = database.put(key[0] == null ? value[0].getKey() : key[0], value[0]);        }        else logger.error("Unable to add new element: not satisfied condition");//          peacher().logboard(3, "Не удалось добавить элемент: не удовлетворяет условию");      } else logger.error("Detected the attempt to add empty element: method execution was interrupted");//        peacher().logboard(1, "Обнаружена попытка добавления пустого элемента: выполнение метода прервано");    }  }  /**   * Общий метод удаления элемента из коллекции:   * Три режима удаления   * <ul>   *   <li>Удаление по ключу</li>   *   <li>Удаление по элменту</li>   *   <li>Удаление по ключу и элементу</li>   * </ul>   * 1. Удаление по ключу включает:   * <ul>   *   <li>Проверка: есть ли такой ключ в базе</li>   *   <li>Удаление элемента</li>   * </ul>   * Этот режим не предполагает пользовательских проверок на соответствие элемента   * 2. Удаление по элементу:   * <ul>   *   <li>Проверка: есть ли такой элемент в коллекции</li>   *   <li>Поиск ключа этого элемента</li>   *   <li>Проверка: подходит ли наш элемент под заданные условия</li>   *   <li>Удаление элемента</li>   *   <li>Проверка: а то ли мы вообще удалили</li>   * </ul>   * Данный режим уже предполагает проверки, на соответсвие признаку   * 3. Миксованное удаление (диджей *бан):   * <ul>   *   <li>Проверка: содержатся ли предоставленные данные одновременно в коллекции (хотя бы даже не в связке)</li>   *   <li>Проверка: есть ли связка ключа и элемента</li>   *   <li>Удаление</li>   * </ul>   * @param key ключ, по которому происходит удаление   * @param value удаляемый элемент   * @param menace признак того, нужно ли удалять данный элемент   */  @Override  public void remove(Integer[] key, OrganizationWithUId[] value, Indicator menace) {    synchronized (database) {      // проверяем нужно ли удалять элемент по ключу      if ((key[0] != null) && (value[0] == null)) {        // проверяем есть ли такой ключ в базе        if (database.containsKey(key[0])) {          // выбрасываем этот мусор из коллекции, и, чтобы подстраховаться, даем ссылку команде, ради дальнейших проверок          value[0] = database.remove(key[0]);//          peacher().notify(0, "Элемент по ключу " + key[0] + " удален");          logger.info("Element by key " + key[0] + " is deleted");        } else logger.error("Unable to delete element: key " + key[0] + " is not found");//          peacher().notify(3, "Невозможно удалить элемент: ключ " + key[0] + " не найден");      } else if ((key[0] == null) && (value[0] != null)) {        // проверили: нужно ли удалить элемент по значению и дальше смотрим, а есть ли эта тварь в коллекции вообще        if (database.containsValue(value[0])) {          // если все-таки есть, то пытаемся найти ключ этой падлы          search(key, value, (v) -> (true)); // а чо зря функцию писал, вот и понадобилась          // делаем проверку: нужно ли удалять этот элемент          if (menace.verify(value[0])) {            // удаляем и сверяем с требуемым на удаление            if (value[0].equals(database.remove(key[0])))//              peacher().notify(0, "Элемент " + value[0].getOrganization().toString() + " успешно удален");                logger.info("Element " + value[0].getOrganization().toString() + " is deleted");              else logger.error("Accidentally deleted wrong element, it would be restored.");//                peacher().notify(2, "Случайно удален не тот элемент, данные будут восстановлены");          } else logger.error("Impossible to delete element: condition wasn't satisfied");//            peacher().notify(3, "Невозможно стереть элемент: не удовлетворяет условию удаления");        } else logger.error("Can't delete element " + value[0].getOrganization().toString() + " because of it's absence");//          peacher().notify(1, "Нельзя удалить элемент " + value[0].getOrganization().toString() + ": из-за его отсутствия");      } else if ((key[0] != null) && (value[0] != null)) {        // проверяем: содержит ли коллекция и ключ, и значение        if ((database.containsKey(key[0])) || (database.containsValue(value[0]))) {          // проверяем: а нужно ли нам все это          if (menace.verify(value[0])) {            // проверяем: удалилось ли            if (database.remove(key[0], value[0])) logger.info("Element deleted successfully");//              peacher().logboard(0, "Удаление прошло успешно");            else logger.error("Couldn't delete element by key: " + key[0] + " and value: " + value[0].getOrganization().toString());//              peacher().notify(1, "Не удалось удалить элемент по ключу " + key[0] + " и значению " + value[0].getOrganization().toString());          } else logger.error("Couldn't delete element: unsatisfied condition");//            peacher().logboard(3, "Не удалось удалить элемент: не подходит под условия");        } else logger.error("Element wasn't found to be deleted");//          peacher().logboard(2, "Данные для удаления не найдены в коллекции");      } else logger.error("Wrong call of command \"remove\"");//        peacher().logboard(0xEE, "Произошел неправильный вызов метода remove");    }  }  /**   * Общий метод поиска элемента. Данный метод, в отличие от предыдущего,   * поддерживает лишь два режима поиска:   * 1. По ключу   * 2. По элементу   * @param key ключ, по которому ищется элемент   * @param value элемент, который мы ищем   * @param menace  признак того, нужен ли нам данный элемент   */  @Override  public void search(Integer[] key, OrganizationWithUId[] value, Indicator menace) {    synchronized (database) {      // проверка: по ключу ли искать      if ((key[0] != null) && (value[0] == null)) {        // проверка: есть ли данный ключ в коллекции        if (database.containsKey(key[0])) {          OrganizationWithUId buffer = database.getOrDefault(key[0], value[0]); // сохраняем найденный элемент          logger.info("Element was found by key: " + key[0]);//          peacher().logboard(0, "В базе найдены данные по Вашему ключу " + key[0]);          if (menace.verify(buffer)) {            value[0] = buffer; // возвращаем найденное наверх            logger.info("Condition was satisfied, elements was given");//            peacher().logboard(0, "Условие удовлетворено, данные предоставлены");          } else logger.error("Condition unsatisfied, elements wasn't given");//            peacher().notify(3, "Условие не удовлетворено, данные не могут быть предоставлены");        } else {          logger.error("Key: " + key[0] + " wasn't found in collection, element couldn't be given");//          peacher().logboard(1, "Ключ " + key[0] + " отсутствует в коллекции, данные по нему не могут быть найдены");          key[0] = null;        }      } else if ((key[0] == null) && (value[0] != null)) {        // проверка: есть ли элемент в коллекции        if (database.containsValue(value[0])) {          // Хайпим на Stream API          OrganizationWithUId finalized = value[0]; // копируем значение, чтобы оно оставалось постоянным, требование ФИ          key[0] = database.entrySet() // получаем множество пар ключ-значение                  .stream() // преобразуем в поток                  .filter(entry -> entry.getValue().equals(finalized.getOrganization()) && menace.verify(entry.getValue().getOrganization())) // оставляем только значения, равные нашему и соответствующие условию                  .map(Map.Entry::getKey) // сохраняем их ключи                  .findFirst() // берем первый ключ                  .orElse(key[0]); // или звоним бывшему (сохраняем прежний ключ)          // возврат ключа наверх          logger.info("Key of element: " + value[0].getOrganization().toString() + " was found" );//          peacher().notify(0, "Найден ключ элемента " + value[0].getOrganization().toString());        } else logger.error("Element " + value[0].getOrganization().toString() + " isn't in collection");//          peacher().notify(2, "Элемент " + value[0].getOrganization().toString() + " отсутствует в коллекции");      } else if ((key[0] == null) && (value[0] == null)) {        // ищем ключ первого элемента, удовлетворяющего признаку        Integer buffer_key =                database                        .entrySet()                        .stream()                        .filter((enter) -> (menace.verify(enter.getValue().getOrganization()))) //TODO: если буйда не работает то было enter.getValue()                        .findFirst().get().getKey();        // возвращаем ключ        key[0] = buffer_key;      } else logger.error("Incorrect call of searching function");//        peacher().logboard(1, "Не корректный вызов функции поиска");    }  }  /**   * Делаем обзор на коллекцию, фильтруя базар   * @param menace this very фильтр   * @return текстовая информация об элементах   */  @Override  public String survey(Indicator menace) {    //TODO:и это говно проверить на работоспособность    synchronized (database) {      StringBuilder bufferSurvey = new StringBuilder();      // добавляем к текущей пустой строке весь текст с готовой информацией      LinkedHashMap<Integer, OrganizationWithUId> tempCollection = ((HashMax) database).sortByNameOfOrganization();      Optional result = tempCollection.entrySet() // получаем пары ключ-значение              .stream() // преобразуем в поток, дабы быть на волне              .filter(entry -> menace.verify(entry.getValue().getOrganization())) // отсеиваем только не нужные              .map((entry) -> ("\tKEY: " + entry.getKey() + ";\n\tVALUE: " + entry.getValue().getOrganization().toString() + ";\n\tOWNER: " + entry.getValue().getUserLogin() + "\n")) // преобразуем в строки с информацией              .reduce((left, right) -> (left.concat(right)));      bufferSurvey.append(result.isPresent() ? result.get() : "no elements"); // формируем единый текст      // Нужно юзать Stream API      // for (Map.Entry<Integer, Organization> entry : database.entrySet())      //  if (menace.verify(entry.getValue()))      //    bufferSurvey.append("KEY: " + entry.getKey() + ";\n\tVALUE: " + entry.getValue() + "\n");      logger.info("Collection's elements data was provided");//      peacher().logboard(0, "Данные по элементам коллекции предоставлены");      return bufferSurvey.toString(); // возвращаем результат    }  }  /**   * Убирать за собой - тоже нужно уметь   */  @Override  public int clear(String userLogin) {    int deletedOrganizations = database.size();    synchronized (database) {     database.entrySet().stream()              .filter((tempEntry) -> (tempEntry.getValue().getUserLogin().equals(userLogin)))             .forEach((corpse)->{                database.remove(corpse.getKey());              });     deletedOrganizations -= database.size();//    database.clear(); // очистка коллекции стандартным методом      logger.info("Collection was cleared successfully");//      peacher().logboard(0, "Коллекция успешно очищена");    }    return deletedOrganizations;  }  /**   * Свойство получения дежурного логгера.   * Нужен, чтобы в наследниках переопределить и возвращать   * более прокачанный логгер.   * @return ссылка на текущий логгер   *///  protected RadioLogger peacher() {//    return whistleblower;//  }  /**   * Сеттер для коллекции,   * после простых проверок,   * тупо загружает все элементы   * в базу   * @param loaded список загруженных элементов   */  @Override  public void DataRebase(List<OrganizationWithUId> loaded) {    loaded        .stream()        .forEach((org) -> { database.put(org.getKey(), org); });    logger.info("Collection loaded successfully");//    peacher().logboard(0, "Коллекция успешно загружена");  }  /**   * Метод сохранения коллекции в xml файл.   */  @Override  public void save() {    synchronized (database.entrySet().iterator()) {      List<OrganizationWithUId> unload = new ArrayList<>();      database              .entrySet()              .stream()              .forEach((Map.Entry<Integer, OrganizationWithUId> org) -> {                unload.add(org.getValue());              });      try {        breadLoader.unload(unload);      } catch (NullPointerException e) {        logger.error("Collection wasn't found");//        System.err.println("Коллекция для сохранения не была онаружена.");        return;      }      logger.info("Collection saved successfully");//      peacher().logboard(0, "Коллекция успешно сохранена");    }  }  public boolean checkIfYours(OrganizationWithUId org1, OrganizationWithUId org2) {      if (org1.getUserLogin().equals(org2.getUserLogin())) return true;      else return false;  }}